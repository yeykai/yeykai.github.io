{"pages":[],"posts":[{"title":"Markdown图片的解决方案---PicGo+腾讯云COS","text":"前言：我现在已经习惯使用Markdown格式来写博客，但是，每次给文章添加图片的过程，都让我感到很烦躁，之前使用过的方式是把图片上传到一些第三方平台（例如简书），在将外链放在markdown中，完成插入图片操作。其实上面的方法也不算太麻烦，但是，好景不长，突然有一天你就发现自己的博客图片加载不出来了，然后我又把插入图片的方式改成本地路径，这样虽然能解决问题，但是过程实在太麻烦了，而且我也没法在编辑过程中预览图片的效果。 直到今天，朋友分享的一个工具—PicGo，解决了这种尴尬的局面。PicGo是一个操作简单效率高的图片上传工具，只需要简单的设置，再把图片拖拽上传，你就可以得到一个可以直接粘贴到markdown的图片链接，整个过程体验非常好。PicGo支持的图床种类丰富，我选择了腾讯云的COS来配合使用，现在新用户用50G半年的免费使用资格，对于存放博客图片绰绰有余。 首先，需要把PicGo下载下来并安装，工具已经开源，在github上就能下载，而且还跨平台，好评！安装完成后，开始配置腾讯云COS，配置前，需要去这里配置访问密钥，这样PicGo才可以正常使用 创建一个存储桶，这里的配置可以根据自己的情况来填，不过这里的访问权限需要改为公有读私有写，如果使用私有读写，上传后的外链就没法直接访问图片了。 查看刚创建的存储桶配置，结合访问密钥，现在可以开始配置PicGo了，将必填的项目按照腾讯云上的数据依次填入，并设为默认图床。 到此，所有配置均已完成，可以尝试上传图片了，选择一张图片拖拽到上传区，就可以看到上传成功的通知了，并且这条链接已经在剪贴板中了。 当然，如果你有已经备案好的域名，也可以更改默认域名，只需要在存储桶配置中更改自定义域名，然后在域名解析设置中，加上映射到这个桶的配置，最后，在PicGo中更改自定义域名，就可以用自己的域名来访问图片了。 最后分享一个刚踩的坑，上传的图片名称最好就不要带括号了，不然复制到markdown，就识别不到了。","link":"/2019/08/26/MarkdownPicGo/"},{"title":"【学习日记】微信小程序发送服务通知接口开发","text":"本文使用的技术栈：小程序开发、SpringBoot、MyBatis、Redis 服务通知是小程序或者公众平台向用户发送的一个消息卡片，可用于用户在应用中完成操作后，给予相应反馈；也可以在后台主动向用户推送，引导用户完成一些必要操作。如下图，就是一个典型的服务通知 今天，我将使用微信提供的接口，开发一个商品购买成功的服务通知。首先看一下官方文档： 从文档中可以看出，过程并不复杂，参数也容易理解。首先，需要使用getAccessToken接口，获取小程序全局唯一后台接口调用凭据access_token；接着，用这个token，携带模板消息信息调用sendTemplateMessage接口完成操作。开发之前，需要在微信公众平台上申请模板消息，它提供了许多类型的模板消息，可根据自己的需要来设置，设置完成后会得到模板id，如下图所示： 最开始，我只是想让用户点击确认订单按钮后，便生成订单并给用户发送服务通知，于是，我便直接在小程序js中调用了这些接口，具体过程代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495onLoad: function (params) { // 首先，获取access_token wx.request({ url: &apos;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&amp;secret=&apos;, method: &quot;GET&quot;, success: function (res) { console.log(res, &quot;res&quot;) console.log(res.data.access_token, &quot;access_token&quot;) //保存access_token me.setData({ access_token: res.data.access_token, }) } })},// 点击执行方法confirmGoods: function (e) { var me = this; var formId = &quot;5fa22cb20938b888927001f8d8deb71b&quot;; // var formId = e.detail.formId; var goodsInfo = me.data.goodsInfo; var serverUrl = app.serverUrl; var confirmId = me.data.id var orderId = &quot;&quot;; console.log(e); console.log(formId); // 保存订单到数据库 wx.request({ //保存商品信息至数据库 ...... me.send(formId, res.data.data); wx.redirectTo({ url: &apos;../goods/goodsCase?tabtype=1&apos;, }) } })}, send:function(formId,orderId){ var me = this; var fId = formId; var goodsInfo = me.data.goodsInfo; goodsInfo.orderId = orderId; var goodsInfoStr = JSON.stringify(goodsInfo); console.log(fId) // 网络请求 var url = &apos;https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=&apos; + me.data.access_token; // 需要传的参数 var data = { //用户的openid touser: &quot;用户openid&quot;, //这个是申请的模板消息id，位置在微信公众平台/模板消息中添加并获取 template_id: &apos;3KKr_Zg8WySQ5qKmn2Fsah9AD6Ls0tDCtT50G5Zh3-8&apos;, //点击通知跳转的页面 page: &apos;/pages/goods/goodsComplete?goodsInfo=&apos; + goodsInfoStr, //表单提交场景下，为 submit 事件带上的 formId form_id: fId, //模板通知数据 data: { &quot;keyword1&quot;: { &quot;value&quot;: goodsInfo.orderId, &quot;color&quot;: &quot;#4a4a4a&quot; }, &quot;keyword2&quot;: { &quot;value&quot;: goodsInfo.goodsName, &quot;color&quot;: &quot;#9b9b9b&quot;, }, &quot;keyword3&quot;: { &quot;value&quot;: goodsInfo.expectPrice, &quot;color&quot;: &quot;#9b9b9b&quot; }, &quot;keyword4&quot;: { &quot;value&quot;: goodsInfo.address, &quot;color&quot;: &quot;#9b9b9b&quot; }, }, color: &apos;#ccc&apos;, } wx.request({ url: url, data: data, method: &apos;POST&apos;, //此处不能有请求头 success: function (res) { console.log(res, &quot;push msg&quot;); }, fail: function (err) { console.log(err, &quot;push err&quot;); } });}, 有几个点这里需要提一下： 1.form_id的获取，需要在form属性的report-submit设置为”ture”，这样提交时，submit事件就会带上formId。 2.每条通知都会消耗一个form_id,通知一旦发送成功，这个form_id就会失效。 3.A用户提交表单得到的form_id，只能用来给A用户发送通知，否则也是无效的 4.form_id有七天有效期。 通过上面的代码，我的小程序向我的微信成功地推送了一条通知，如下图所示： 虽然我的需求是实现了，但是，仔细思考一下，这种解决方式并不是很理想，并且官方也不推荐这种做法。因为，很多场景并不是用户提交表单的那一瞬间去发送通知，而是需要其他时间，由服务器主动地向用户推送通知。当然，无论是什么场景，官方的建议都是通过后端服务器去调用这些接口。 接下来，我就对我的后端代码进行改造，编写一些工具类和实体类：1234567891011121314151617181920212223//模板消息信息实体类public class WechatTemplate { //用户openId private String touser; //模板Id private String template_id; //通知跳转路径（小程序内路径） private String page; //接收到的form_id private String form_id; //通知具体数据信息 private Map&lt;String, TemplateData&gt; data; //字体颜色，非必选项 private String color; // ...get、set、toString方法省略... } 12345678910111213141516//getAccessToken接口返回实体public class WxToken { //获取到的凭证 private String access_token; //凭证有效时间，单位：秒。目前是7200秒之内的值。 private String expires_in; //错误码 private String errcode; //错误信息 private String errmsg; // ...get、set、toString方法省略... } 1234567//模板通知内容实体public class TemplateData { private String value; //该值的字体颜色 private String color; // ...get、set、toString方法省略... } 1234567//微信接口返回实体public class WxResponse { private Integer errcode; private String errmsg; private String msgid; // ...get、set、toString方法省略... } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import com.google.gson.Gson;import com.yeykai.pojo.*;import com.yeykai.service.WxService;import com.yeykai.utils.HttpClientUtil;import com.yeykai.utils.JsonUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;import java.util.Date;import java.util.HashMap;import java.util.Map;import java.util.TreeMap;@Servicepublic class WxServiceimpl implements WxService { //日志输出 private static Logger logger = LoggerFactory.getLogger(WxServiceimpl.class); //微信模板接口 private final String SEND_TEMPLAYE_MESSAGE_URL =&quot;https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=ACCESS_TOKEN&quot;; private final String APPID = &quot;你的appid&quot;; private final String SECRET = &quot;你的app密钥&quot;; //获取微信ACCESS_TOKEN接口url private final String aturl = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&quot; + APPID + &quot;&amp;secret=&quot; + SECRET; public WxToken getAccess_token() { String access_token = &quot;&quot;; //获取ACCESS_TOKEN String httpGet = HttpClientUtil.doGet(aturl); Gson gson=new Gson(); //得到返回对象 WxToken jsonResult=new WxToken(); jsonResult = gson.fromJson(httpGet, WxToken.class); //判断请求是否成功 if(jsonResult.getErrcode() == null){ //输出返回结果 System.out.println(&quot;get请求结果:&quot; + httpGet); access_token = jsonResult.getAccess_token(); String expires_in =jsonResult.getExpires_in(); logger.info(&quot;access_token{}: expires_in{}:&quot;,access_token,expires_in); }else { logger.info(&quot;token获取失败，错误码：&quot;+jsonResult.getErrcode()); logger.info(&quot;错误信息：&quot;+jsonResult.getErrmsg()); } //返回ACCESS_TOKEN return jsonResult; } //发送模板信息 @Override public void sendTemplateMessage(WechatTemplate wechatTemplate) { //获取ACCESS_TOKEN WxServiceimpl wx = new WxServiceimpl(); WxToken wxToken = wx.getAccess_token(); String access_token=wxToken.getAccess_token(); String jsonString = JsonUtils.objectToJson(wechatTemplate); //填充请求url String requestUrl = SEND_TEMPLAYE_MESSAGE_URL.replace(&quot;ACCESS_TOKEN&quot;, access_token); //发送 post请求 发送json数据 logger.info(&quot;请求参数:&quot;+jsonString); String json = HttpClientUtil.doPostJson(requestUrl, jsonString); WxResponse weiXinResponse = new Gson().fromJson(json, WxResponse.class); logger.info(&quot;jsonObject=&quot;+weiXinResponse); if (null != weiXinResponse) { int errorCode = weiXinResponse.getErrcode(); if (0 == errorCode) { logger.info(&quot;模板消息发送成功&quot;); } else { String errorMsg = weiXinResponse.getErrmsg(); logger.info(&quot;模板消息发送失败,错误是 &quot;+errorCode+&quot;,错误信息是&quot;+ errorMsg); } } }} 实体类和业务类已经完成，接下来，开发Controller层，最后做前后端联调测试。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//用户确认商品信息后，提交订单，调用该接口 @PostMapping(&quot;/addOrder&quot;) public IMoocJSONResult addOrder(String confirmId,String formId) { //订单id String id = &quot;&quot;; //模板消息对象 WechatTemplate wechatTemplate = new WechatTemplate(); if (confirmId!=null) { ConfirmGoods confirmGoods = orderService.queryConfirm(confirmId); String buyerId = confirmGoods.getBuyerId(); String goodsID= confirmGoods.getGoodsId(); Goods goodsinfo = goodsService.queryGoodsInfo(goodsID); //...数据库操作省略 String goodsJsonStr = JsonUtils.objectToJson(goodsinfo); wechatTemplate.setTemplate_id(&quot;模板id&quot;); //设置用户的OpenId wechatTemplate.setTouser(&quot;openid&quot;); //设置跳转页面路径 wechatTemplate.setPage(&quot;/pages/goods/goodsComplete?goodsInfo=&quot;+goodsJsonStr); //设置form_Id wechatTemplate.setForm_id(formId); //补充通知内容数据 Map&lt;String,TemplateData&gt; m = new TreeMap&lt;String,TemplateData&gt;(); TemplateData keyword1 = new TemplateData(); keyword1.setValue(id); m.put(&quot;keyword1&quot;, keyword1); TemplateData keyword2 = new TemplateData(); keyword2.setValue(goodsinfo.getGoodsName()); m.put(&quot;keyword2&quot;, keyword2); TemplateData keyword3 = new TemplateData(); keyword3.setValue(goodsinfo.getCreateTime().toString()); m.put(&quot;keyword3&quot;, keyword3); TemplateData keyword4 = new TemplateData(); keyword4.setValue(goodsinfo.getPrice().toString()+&quot;元&quot;); m.put(&quot;keyword4&quot;, keyword4); TemplateData keyword5 = new TemplateData(); keyword5.setValue(goodsinfo.getAddress()); m.put(&quot;keyword5&quot;, keyword5); wechatTemplate.setData(m); //发送服务通知 wxService.sendTemplateMessage(wechatTemplate); return IMoocJSONResult.ok(id); } return IMoocJSONResult.errorMsg(&quot;生成订单失败&quot;); } 开发完毕，这次，我采用谷歌浏览器很好用的一款REST API测试工具来测试，测试使用的form_id是我预先用自己的微信发送请求采集好的。如下图所示： 现在点击发送请求，结果如下：日志打印结果成功 测试结果返回正常 最后看一下手机上收到的通知，由于我的小程序还没申请上线，所以小程序头像和名称就没有啦 点击进入小程序后，数据接收正常 最后总结一下： 1.再简单的接口，不动手写一下，是发现不了自己的问题的 2.使用这类微信提供的接口时，一定要看清每个url对应的功能，我就因为这个错误找了半天bug，一直不相信自己会把这个写错。emmm 3.form_id的采集可以改造一下前端代码，给每个form表单的submit都加上form_id,然后把它们收集起来，存入数据库，需要时在用它主动向用户推送通知，当然，也要注意推送频率，被用户举报后果严重。 最常遇到的错误码：47001和40003。47001一般是提交请求的数据格式出错，这里可以把提交的数据打印再日志上，通过json格式检验工具来检查格式问题。 40003则是用户的openId错误，或是获取ACCESS_TOKEN时填入的appid出错，还有可能是url错误，例如把 “https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=ACCESS_TOKEN&quot;错写成&quot;https://api.weixin.qq.com/cgi-bin/message/wxopen/template/uniform_send?access_token=ACCESS_TOKEN&quot;,emmm,就是我。 其他的错误官方也给出了一些原因： 最后，分享一张壁纸","link":"/2018/12/05/miniInterface/"},{"title":"【学习日记】微信小程序仿朋友圈发布商品信息及图片","text":"本文使用的技术栈：小程序开发、SpringBoot、MyBatis、Redis 今天要写一个商城项目中的发布商品模块，需求跟闲鱼这样的app基本一致，就是基本的上传表单数据和图片。图片模块我想采用类似朋友圈的方式来完成，符合大部分用户的操作逻辑。 现在朋友圈发图片已经可以拖拽改变图片顺序或删除图片了，但是用小程序实现拖拽功能太麻烦了。所以，我将换一种方式来实现图片删除和预览，最后，再写两个后端接口，把商品信息和图片存入数据库。 这里前端用到了Vant Weapp的UI库 https://github.com/youzan/vant-weapp 先来看看前端页面的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;view class=\"page\"&gt; &lt;form bindsubmit='send'&gt; &lt;van-cell-group&gt; &lt;van-field required clearable left-icon=\"gift\" name=\"goodsName\" label=\"商品名称\" icon=\"question\" placeholder=\"请输入商品名\" bind:click-icon=\"onClickIcon\" /&gt; &lt;van-field type=\"textarea\" label=\"描述\" left-icon=\"records\" name=\"goodsDesc\" placeholder=\"请输入5-50个字\" autosize required border=\"{{ false }}\" /&gt; &lt;/van-cell-group&gt; &lt;view class=\"image_content\"&gt; &lt;view class='image' wx:for=\"{{img_url}}\"&gt; &lt;image class=\"deleteImg\" mode=\"aspectFill\" data-index='{{index}}' src=\"/img/deleteImg.png\" bindtap=\"deleteImg\"&gt;&lt;/image&gt; &lt;image class=\"moment_img\" mode=\"aspectFill\" data-index='{{index}}' src=\"{{item}}\" bindtap=\"previewImg\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class='image' style='display:{{hideAdd?\"none\":\"block\"}}'&gt; &lt;image bindtap=\"chooseimage\" class=\"moment_img\" src='/img/addImg.png'&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;van-cell-group&gt; &lt;van-field required clearable left-icon=\"gold-coin\" name=\"goodsPrice\" label=\"单价\" icon=\"question\" placeholder=\"请输入数字\" bind:click-icon=\"onClickIcon\" /&gt; &lt;van-field value=\"1\" label=\"数量\" left-icon=\"exchange\" name=\"goodsNum\" placeholder=\"\" required /&gt; &lt;van-field left-icon=\"chat\" name=\"goodsPhone\" label=\"联系方式\" required /&gt; &lt;van-field left-icon=\"location\" value=\"\" name=\"goodsAddress\" label=\"交易地点\" placeholder=\"例：学瀚楼下\" required /&gt; &lt;/van-cell-group&gt; &lt;button class=\"publishBtn\" type=\"primary\" form-type='submit'&gt;发布&lt;/button&gt; &lt;/form&gt;&lt;/view&gt; 效果如下图： 表单部分代码很简单，所以这里主要分析添加图片的代码逻辑。第一步，找一张添加照片的图标绑定一个wx.chooseImage事件，定义一个全局变量count作为当前选择的图片数量，使用户选择的图片在9张以内；定义一个数组，用于存放当前图片的url，在用户选择完照片后，该数组会更新，并用wx:for渲染至前端页面。123456789101112131415161718192021222324252627282930313233chooseimage: function () { var me = this; //动态更新当前用户可以上传的图片数 var count = 9 - that.data.img_url.length; wx.chooseImage({ count: count, // 默认9 sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有 sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有 success: function (res) { if (res.tempFilePaths.length &gt; 0) { //把每次选择的图push进数组 let img_url = that.data.img_url; for (let i = 0; i &lt; res.tempFilePaths.length; i++) { img_url.push(res.tempFilePaths[i]) } me.setData({ img_url: img_url }) //图如果满了9张，不显示添加图片图标 if (that.data.img_url.length &gt;= 8) { me.setData({ hideAdd: 1 }) } else { me.setData({ hideAdd: 0 }) } } } }) } 当图片数量达到9张，隐藏添加图片图标 第二步，给图片加上预览和删除功能，预览功能使用wx.previewImage绑定图片的索引值即可；删除功能则是在图片右上角加上一个删除图标来绑定删除事件，删除后实时更新图片列表。 1234567891011121314151617181920212223242526//预览图片previewImg:function(e){ var me = this; var img_url = me.data.img_url; var index = e.target.dataset.index; wx.previewImage({ urls: img_url, current : img_url[index], success:function(res){ console.log(res); } })},//删除图片deleteImg: function (e){ var me = this; var img_url = me.data.img_url; var index = e.target.dataset.index; img_url.splice(index, 1); me.setData({ img_url: img_url, //若当前图片超过9张，则隐藏添加图标；少于9张则显示添加图标。 hideAdd: me.data.img_url.length &lt;9 ? false : true })}, 第三步，上传商品信息和图片，我将这个功能分为两部分完成，首先将表单数据先上传，再将图片上传。这里假设用户已经成功使用微信登录小程序，且登录态保存已保存在本地缓存。在表单数据上传成功后，会返回一个商品ID到前端，再调用上传图片方法，将商品ID和每张图片的相对路径保存至数据库。实现代码如下。1234567891011121314151617181920212223242526272829303132333435//上传商品信息send:function(e){ var me = this; console.log(e); var goodsName = e.detail.value.goodsName; var goodsDesc = e.detail.value.goodsDesc; var goodsPrice = e.detail.value.goodsPrice; var goodsNum = e.detail.value.goodsNum; var goodsAddress = e.detail.value.goodsAddress; var goodsPhone = e.detail.value.goodsPhone; var thirdSession = wx.getStorageSync(\"thirdsession\") wx.showLoading({ title: '发布中--', }) var serverUrl = app.serverUrl; wx.request({ url: serverUrl + '/goods/uploadGoods', data: { thirdSession: thirdSession, goodsName: goodsName, goodsDesc: goodsDesc, goodsPrice: goodsPrice, goodsNum: goodsNum, goodsAddress: goodsAddress, goodsPhone: goodsPhone, }, method: \"GET\", success: function (res) { wx.hideLoading(); console.log(res.data.data); //商品信息上传成功后，上传商品图片 me.uploadGoodsImg(res.data.data); } }) } 需要注意的是，小程序的wx.uploadFile接口的资源路径是String类的。所以多图上传时，我会递归调用这个接口来完成。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//上传图片uploadGoodsImg: function (goodsId){ var me = this; var imgFilePaths = me.data.img_url; var count = me.data.count; var serverUrl = app.serverUrl; wx.showLoading({ title: '上传图片中--', }) wx.uploadFile({ url: serverUrl + '/goods/uploadGoodsImg', filePath: imgFilePaths[count], name: 'file', formData: { goodsId: goodsId }, success: function (res) { //可统计成功上传图片数 }, fail: function (res) { //可统计上传失败图片数 }, complete: function (res) { count++; me.setData({ count: count }) if (count &gt;= imgFilePaths.length) { var data = JSON.parse(res.data); console.log(data); wx.hideLoading(); if (data.status == 200) { wx.hideLoading(); wx.showToast({ title: '上传成功!~~', icon: 'success' }); me.setData({ count: 0 }) } else if (data.status == 500) { wx.showToast({ title: data.msg, }); } } else { //图片未上传完，递归调用本方法。 me.uploadGoodsImg(goodsId); } } }) } 第四步，后端接口使用IO流工具IOUtils将图片写入到指定的路径下，并将相对路径保存至数据库。这里存放图片路径采用了一个单独的表。具体代码如下：12345678910111213141516171819202122232425262728293031323334353637 //保存商品信息@GetMapping(\"/uploadGoods\")public IMoocJSONResult uploadFace(String thirdSession,String goodsName, String goodsDesc,double goodsPrice,String goodsPhone, int goodsNum,String goodsAddress) throws Exception { if (StringUtils.isBlank(thirdSession)) { return IMoocJSONResult.errorMsg(\"thirdSession is none\"); } String value = (String) redis.get(\"Wxuser-redis-session:\"+thirdSession); System.out.println(value); if (StringUtils.isBlank(value)) { return IMoocJSONResult.errorMsg(\"session timeout\"); } //解析json格式的str JSONObject json = JSONObject.parseObject(value); String openId = json.getString(\"openid\"); String goodsId = sid.nextShort(); Goods goods = new Goods(); goods.setId(goodsId); goods.setSellerId(openId); goods.setSellerPhone(goodsPhone); goods.setAddress(goodsAddress); goods.setGoodsDesc(goodsDesc); goods.setLikeCounts(0); goods.setGoodsName(goodsName); goods.setPrice(goodsPrice); goods.setGoodsNum(goodsNum); goodsService.saveGoods(goods); return IMoocJSONResult.ok(goodsId);} 上传图片接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@PostMapping(value=\"/uploadGoodsImg\" ,headers=\"content-type=multipart/form-data\")public IMoocJSONResult uploadGoodsImg(String goodsId,@RequestParam(\"file\") MultipartFile[] files) throws Exception { //文件保存的命名空间 String fileSpace=\"D:/cunjin-xianyu-test\"; //保存到数据库的相对路径 String uploadPathDB=\"/\"+goodsId+\"/img\"; FileOutputStream fileOutputStream=null; InputStream inputStream= null; try { if(files != null &amp;&amp; files.length&gt;0) { String fileName= files[0].getOriginalFilename(); if (StringUtils.isNotBlank(fileName)) { //文件保存的最终路径 String finalPath = fileSpace + uploadPathDB + \"/\" + fileName; //设置数据库保存的路径 uploadPathDB+=(\"/\"+fileName); File outFile=new File(finalPath); if (outFile.getParentFile()!=null || !outFile.getParentFile().isDirectory()) { //创建父文件夹 outFile.getParentFile().mkdirs(); } fileOutputStream = new FileOutputStream(outFile); inputStream = files[0].getInputStream(); IOUtils.copy(inputStream, fileOutputStream); }else { return IMoocJSONResult.errorMsg(\"上传出错\"); } } } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); return IMoocJSONResult.errorMsg(\"上传出错\"); }finally { if(fileOutputStream!=null) { fileOutputStream.flush(); fileOutputStream.close(); } } GoodsImg goodsImg = new GoodsImg(); goodsImg.setGoodsId(goodsId); goodsImg.setImg(uploadPathDB); goodsService.saveGoodsImg(goodsImg); return IMoocJSONResult.ok(\"上传成功\");} 好了，代码写完了，现在来进行前后端联调，测试一下。我们先选几张图，输一些数据 在本地新建一个文件夹，用于存放图片，路径与代码的命名空间一致。 好了，现在我们点击发布，观察数据库和本地文件。 可以看到，我们发布的商品信息和图片相对路径都已经存入数据库了，同时，本地也已经保存了这两张图片。测试成功！总结 数据库存放多张图片路径，除了用本文的方法，还可以使用一些特定符号将路径分隔开，存入商品信息表中，这样，即使上传多张图片也只会存入一行数据，不过这种方法也是在网上看过，自己还未实践过。 在使用wx.uploadFile接口时，要记得将content-type改为multipart/form-data。 使用IOUtils写文件的拷贝非常方便，无需各种输入流，然后读取line，输出到输出流。","link":"/2018/09/29/miniPublishImg/"},{"title":"使用Hexo+Icarus搭建个人博客的细节分享（持续更新）","text":"本文使用的技术栈：Hexo，css 搭建一个个人博客，让自己抽空写篇文章总结经验，对于程序员来说是非常有意义的事，但作为一个后端开发，前端技术鸡肋的我，还是选择hexo这样的框架来快速建站。 关于怎么用hexo搭建博客，这里就不赘述了，百度已经有非常详细的教程，本文主要分享一些小细节。关于博客主题的选择，这个还是要看个人审美，主流的有next，但我选择比较小众的lcarus。 主题的使用非常简单，这里假设你已经搭建好hexo，只需要将下载好的主题文件夹，放在theme目录下，并修改配置文件_config.yml的theme为icarus，然后hexo cl , g ,s 一顿操作之后就能在本地浏览效果了。 1.更换主题后页面的中文设置：这个只需修改根目录配置文件的language即可，具体修改为什么，一定要看下主题目录下的language文件夹的文件名，icarus的中文文件名就是zh-CN,所以把目录配置文件的language修改为zh-CN即可 2.关于图标的问题：主题配置文件中有一些fab开头的图标，实际上是引用了fontawesome的图标，因此如果换上自己喜欢的图标，只需要到这里选择图标后，把代码复制到配置文件即可，我用了微信和qq两个图标放在左侧的个人简介处，因为自带的Facebook，推特那些账号我没有。 3.改变文章的行距：默认的行距让文章看起来非常挤，因此可以修改一下主题的源码，让行距变大，在浏览器中可以看到文章段落的样式由content这个类来控制，因此，在\\icarus\\source\\css\\style.styl中，我们可以看到这个样式的定义，给它加上line-height属性就好了，同理，你还可以给段首加上空格。","link":"/2019/08/23/hexoexp/"},{"title":"微信小程序使用微信开放接口完成用户注册登录业务","text":"本文使用的技术栈：小程序开发、SpringBoot、MyBatis、Redis 众所周知，登录注册功能一直是一个软件必不可少的一个模块，传统的操作逻辑需要用户手动输入账户和密码才能完成。随着使用软件数量的增加，用户难免会出现记错密码的情况，给自己带来不必要的麻烦。因此，类似微信账号一键登录app这样简单，快捷的操作逐渐得到用户的认可。 在小程序开发中，微信官方很友好地开放了Wx.login这种接口来获取用户的身份标识别。本文将分析这一登录接口实现过程，最终完成小程序用户微信登录功能。首先，我们看一下微信官方给出的登录流程时序图 现在，我们根据这张图用代码来实现它。第一步，我们在原有的小程序登录页面中加入一个微信登录按钮，注意，这个按钮需要有bindgetuserinfo属性来获取用户的加密数据，同时，设置open-type=”getUserInfo”，属性才会生效。1&lt;button class=\"goRegistBtn\" type=\"primary\" open-type='getUserInfo' bindgetuserinfo='doLogin'&gt;微信登录&lt;/button&gt; 第二步，在小程序端调用Wx.login获取临时登录凭证code，传至我们的后台服务器，具体代码如下：1234567891011121314151617181920212223242526doLogin: function (e) { // 登录 wx.login({ success: function(res) { console.log(res) // 获取登录的临时凭证 var code = res.code; // 调用后端，获取微信的session_key, secret wx.request({ //使用本地服务器做测试 url: \"http://192.168.1.102:8080/wxLogin\", data:{ code: code }, success: function(result) { console.log(result); // 保存用户信息到本地缓存 app.setGlobalUserInfo(e.detail.userInfo); wx.redirectTo({ url: '../index/index', }) } }) } })} 第三步，我们在后台接收到小程序前端传来的code后，结合开发者的appid和appsecret，向微信接口服务交换用户的包含openId和Session_key的JSON字符串，然后我们需要在生成一个随机数作为登录态，最后，以登录态作为键，JSON字符串作为值保存至Redis缓存中。具体代码如下：123456789101112131415161718192021222324252627@GetMapping(\"/wxLogin\")public IMoocJSONResult wxLogin(String code) { //微信接口地址 String url = \"https://api.weixin.qq.com/sns/jscode2session\"; //将code,appid,appsecret存入map Map&lt;String, String&gt; param = new HashMap&lt;&gt;(); //开发者自己的appid和secret，这里用xxxxx填充 param.put(\"appid\", \"xxxxx\"); param.put(\"secret\", \"xxxxx\"); param.put(\"js_code\", code); param.put(\"grant_type\", \"authorization_code\"); //使用http客户端工具完成交换请求，获得包含openId和session_key的字符串数组 String wxResult = HttpClientUtil.doGet(url, param); //随机生成一段随机数 int hashCodeV = UUID.randomUUID().toString().hashCode(); if (hashCodeV &lt; 0) { hashCodeV = -hashCodeV; } //生成自定义登录态 String thirdSession = new Random(10).nextInt(8) + 1 + String.format(\"%015d\", hashCodeV); // 存入redis,加入user-redis-session:作为前缀，方便管理。 redis.set(\"Wxuser-redis-session:\" + thirdSession,wxResult,1000 * 60 * 30); //向小程序返回登录态 return IMoocJSONResult.ok(thirdSession);} 第四步，我们要将微信用户的数据保存到数据库中，完成用户注册业务。在最开始，我们点击微信登录按钮后，我们获取到了一些用户的加密数据，这些数据需要传到后台服务器进行校验签名和解密，来保证数据不被篡改。数据如下图所示： 这里需要解释一下几个关键参数的属性 1.encryptedData：加密的用户敏感数据2.signature:签名，signature=sha1(rawData+session_key )3.iv：对称解密算法初始向量 再来看看微信官方的开放数据校验与解密的流程图 现在我们可以开发注册功能了，由于只是要把功能调试成功，我就直接在已有的项目上开发了，一些工具类的实现原理这里就不做分析了。小程序前端请求代码：123456789101112131415161718192021222324252627//获取开放数据var encryptedData = e.detail.encryptedDatavar signature = e.detail.signaturevar iv = e.detail.ivvar rawData = e.detail.rawData//从本地缓存中取出thirdsessionvar thirdsession = wx.getStorageSync('thirdsession')wx.request({ url: 'http://192.168.1.102:8080/wxRegister', //后端请求地址 method: \"GET\", data: { thirdSession: thirdsession, encryptedData: encryptedData, rawData: rawData, signature: signature, iv: iv }, header: { 'content-type': 'application/json' // 默认值 }, success: function (res) { //成功后跳转至用户信息页面 wx.redirectTo({ url: '../mine/mine', }) }}) 后端接口请求代码：12345678910111213141516171819202122232425262728293031323334@GetMapping(\"/wxRegister\") public IMoocJSONResult wxRegister(String thirdSession, String signature, String rawData, String encryptedData, String iv) { //1.根据小程序前端传来的thirdSession，在redis中找出对应的openId和session_key String value = (String) redis.get(\"Wxuser-redis-session:\"+thirdSession); if (StringUtils.isBlank(value)) { return IMoocJSONResult.errorMsg(\"请求超时\"); } //解析json格式的str JSONObject json = JSONObject.parseObject(value); //取出session_key String sessionKey = json.getString(\"session_key\"); //数据签名校验 if (!this.wxService.getUserService().checkUserInfo(sessionKey, rawData, signature)) { return IMoocJSONResult.errorMsg(\"数据签名校验失败\"); } // 解密用户信息 WxMaUserInfo userInfo = this.wxService.getUserService().getUserInfo(sessionKey, encryptedData, iv); WxUser wxuser = wxUserService.queryUserInfo(userInfo.getOpenId()); if (wxuser == null) { WxUser wxUserInfo = new WxUser(); wxUserInfo.setOpenid(userInfo.getOpenId()); wxUserInfo.setNickname(userInfo.getNickName()); wxUserInfo.setCity(userInfo.getCity()); wxUserInfo.setRegistertime(new Date()); wxUserService.saveUser(wxUserInfo); return IMoocJSONResult.ok(\"用户注册成功!\"); }else { return IMoocJSONResult.ok(\"用户信息验证成功\"); } } 再写一个用户信息页面，用于登录成功后显示用户信息,检验登录态是否有效。1234567891011121314151617181920212223242526//mine.jsonLoad:function(params){var me = this;wx.hideToast();//检验登录态是否有效。wx.checkSession({ success: function (res){ console.log(res); }, fail: function (res) { wx.showToast({ title: '登陆态已失效，请重新登陆', }) //失效返回重新登录 wx.redirectTo({ url: '../WxLogin/login', }) }})//获取全局用户信息var userInfo = app.getGlobalUserInfo();me.setData({ userInfo: userInfo, nickname: userInfo.nickName})}, 至此，前后端均开发完毕，我在原有项目的数据库中新建了一张表用于测试，表结构如下： 最后，运行后端工程和Redis，与小程序前端进行联调，测试功能是否能成功运行。 1.在小程序端点击微信登录，后端能成功使用Code交换openId和Session_key，与随机生成的登录态一起存入redis，测试结果如下： 小程序端向用户发起授权请求 后端用接受到的code交换openId和session_key 生成随机数登录态，组成键-值存入Redis 2.从前端获取小程序本地缓存中的thirdsession以及用户的加密信息，进行身份校验和信息解密，解密后的数据存入数据库。 根据thirdsession，从Redis中取出session_key 将用户信息进行解密，存入数据表 3.跳转至用户信息页面，检验登录态是否有效，获取全局用户信息填充至页面。 登录态有效 用户信息填充成功 现在，整个模块均开发测试完成。一个看似简单的模块换了另一种解决方法，这个过程我踩了许多坑，犯了许多低级的错误，因此决定写下这篇文章来总结一下自己的开发经验，让思路更清晰。若各位大神发现代码中有bug的话，可以关注我在后台留言告诉我哦。最后，RNG牛逼！","link":"/2018/09/15/miniLogin/"}],"tags":[{"name":"PicGo","slug":"PicGo","link":"/tags/PicGo/"},{"name":"腾讯云COS","slug":"腾讯云COS","link":"/tags/腾讯云COS/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/微信小程序/"},{"name":"myBatis","slug":"myBatis","link":"/tags/myBatis/"},{"name":"服务通知","slug":"服务通知","link":"/tags/服务通知/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"微信登录接口","slug":"微信登录接口","link":"/tags/微信登录接口/"}],"categories":[{"name":"经验分享","slug":"经验分享","link":"/categories/经验分享/"},{"name":"学习日记","slug":"学习日记","link":"/categories/学习日记/"}]}