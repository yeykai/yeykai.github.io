{"pages":[],"posts":[{"title":"微信小程序使用微信开放接口完成用户注册登录业务","text":"本文使用的技术栈：小程序开发、SpringBoot、MyBatis、Redis 众所周知，登录注册功能一直是一个软件必不可少的一个模块，传统的操作逻辑需要用户手动输入账户和密码才能完成。随着使用软件数量的增加，用户难免会出现记错密码的情况，给自己带来不必要的麻烦。因此，类似微信账号一键登录app这样简单，快捷的操作逐渐得到用户的认可。 在小程序开发中，微信官方很友好地开放了Wx.login这种接口来获取用户的身份标识别。本文将分析这一登录接口实现过程，最终完成小程序用户微信登录功能。首先，我们看一下微信官方给出的登录流程时序图 现在，我们根据这张图用代码来实现它。第一步，我们在原有的小程序登录页面中加入一个微信登录按钮，注意，这个按钮需要有bindgetuserinfo属性来获取用户的加密数据，同时，设置open-type=”getUserInfo”，属性才会生效。1&lt;button class=\"goRegistBtn\" type=\"primary\" open-type='getUserInfo' bindgetuserinfo='doLogin'&gt;微信登录&lt;/button&gt; 第二步，在小程序端调用Wx.login获取临时登录凭证code，传至我们的后台服务器，具体代码如下：1234567891011121314151617181920212223242526doLogin: function (e) { // 登录 wx.login({ success: function(res) { console.log(res) // 获取登录的临时凭证 var code = res.code; // 调用后端，获取微信的session_key, secret wx.request({ //使用本地服务器做测试 url: \"http://192.168.1.102:8080/wxLogin\", data:{ code: code }, success: function(result) { console.log(result); // 保存用户信息到本地缓存 app.setGlobalUserInfo(e.detail.userInfo); wx.redirectTo({ url: '../index/index', }) } }) } })} 第三步，我们在后台接收到小程序前端传来的code后，结合开发者的appid和appsecret，向微信接口服务交换用户的包含openId和Session_key的JSON字符串，然后我们需要在生成一个随机数作为登录态，最后，以登录态作为键，JSON字符串作为值保存至Redis缓存中。具体代码如下：123456789101112131415161718192021222324252627@GetMapping(\"/wxLogin\")public IMoocJSONResult wxLogin(String code) { //微信接口地址 String url = \"https://api.weixin.qq.com/sns/jscode2session\"; //将code,appid,appsecret存入map Map&lt;String, String&gt; param = new HashMap&lt;&gt;(); //开发者自己的appid和secret，这里用xxxxx填充 param.put(\"appid\", \"xxxxx\"); param.put(\"secret\", \"xxxxx\"); param.put(\"js_code\", code); param.put(\"grant_type\", \"authorization_code\"); //使用http客户端工具完成交换请求，获得包含openId和session_key的字符串数组 String wxResult = HttpClientUtil.doGet(url, param); //随机生成一段随机数 int hashCodeV = UUID.randomUUID().toString().hashCode(); if (hashCodeV &lt; 0) { hashCodeV = -hashCodeV; } //生成自定义登录态 String thirdSession = new Random(10).nextInt(8) + 1 + String.format(\"%015d\", hashCodeV); // 存入redis,加入user-redis-session:作为前缀，方便管理。 redis.set(\"Wxuser-redis-session:\" + thirdSession,wxResult,1000 * 60 * 30); //向小程序返回登录态 return IMoocJSONResult.ok(thirdSession);} 第四步，我们要将微信用户的数据保存到数据库中，完成用户注册业务。在最开始，我们点击微信登录按钮后，我们获取到了一些用户的加密数据，这些数据需要传到后台服务器进行校验签名和解密，来保证数据不被篡改。数据如下图所示： 这里需要解释一下几个关键参数的属性 1.encryptedData：加密的用户敏感数据2.signature:签名，signature=sha1(rawData+session_key )3.iv：对称解密算法初始向量 再来看看微信官方的开放数据校验与解密的流程图 现在我们可以开发注册功能了，由于只是要把功能调试成功，我就直接在已有的项目上开发了，一些工具类的实现原理这里就不做分析了。小程序前端请求代码：123456789101112131415161718192021222324252627//获取开放数据var encryptedData = e.detail.encryptedDatavar signature = e.detail.signaturevar iv = e.detail.ivvar rawData = e.detail.rawData//从本地缓存中取出thirdsessionvar thirdsession = wx.getStorageSync('thirdsession')wx.request({ url: 'http://192.168.1.102:8080/wxRegister', //后端请求地址 method: \"GET\", data: { thirdSession: thirdsession, encryptedData: encryptedData, rawData: rawData, signature: signature, iv: iv }, header: { 'content-type': 'application/json' // 默认值 }, success: function (res) { //成功后跳转至用户信息页面 wx.redirectTo({ url: '../mine/mine', }) }}) 后端接口请求代码：12345678910111213141516171819202122232425262728293031323334@GetMapping(\"/wxRegister\") public IMoocJSONResult wxRegister(String thirdSession, String signature, String rawData, String encryptedData, String iv) { //1.根据小程序前端传来的thirdSession，在redis中找出对应的openId和session_key String value = (String) redis.get(\"Wxuser-redis-session:\"+thirdSession); if (StringUtils.isBlank(value)) { return IMoocJSONResult.errorMsg(\"请求超时\"); } //解析json格式的str JSONObject json = JSONObject.parseObject(value); //取出session_key String sessionKey = json.getString(\"session_key\"); //数据签名校验 if (!this.wxService.getUserService().checkUserInfo(sessionKey, rawData, signature)) { return IMoocJSONResult.errorMsg(\"数据签名校验失败\"); } // 解密用户信息 WxMaUserInfo userInfo = this.wxService.getUserService().getUserInfo(sessionKey, encryptedData, iv); WxUser wxuser = wxUserService.queryUserInfo(userInfo.getOpenId()); if (wxuser == null) { WxUser wxUserInfo = new WxUser(); wxUserInfo.setOpenid(userInfo.getOpenId()); wxUserInfo.setNickname(userInfo.getNickName()); wxUserInfo.setCity(userInfo.getCity()); wxUserInfo.setRegistertime(new Date()); wxUserService.saveUser(wxUserInfo); return IMoocJSONResult.ok(\"用户注册成功!\"); }else { return IMoocJSONResult.ok(\"用户信息验证成功\"); } } 再写一个用户信息页面，用于登录成功后显示用户信息,检验登录态是否有效。1234567891011121314151617181920212223242526//mine.jsonLoad:function(params){var me = this;wx.hideToast();//检验登录态是否有效。wx.checkSession({ success: function (res){ console.log(res); }, fail: function (res) { wx.showToast({ title: '登陆态已失效，请重新登陆', }) //失效返回重新登录 wx.redirectTo({ url: '../WxLogin/login', }) }})//获取全局用户信息var userInfo = app.getGlobalUserInfo();me.setData({ userInfo: userInfo, nickname: userInfo.nickName})}, 至此，前后端均开发完毕，我在原有项目的数据库中新建了一张表用于测试，表结构如下： 最后，运行后端工程和Redis，与小程序前端进行联调，测试功能是否能成功运行。 1.在小程序端点击微信登录，后端能成功使用Code交换openId和Session_key，与随机生成的登录态一起存入redis，测试结果如下： 小程序端向用户发起授权请求 后端用接受到的code交换openId和session_key 生成随机数登录态，组成键-值存入Redis 2.从前端获取小程序本地缓存中的thirdsession以及用户的加密信息，进行身份校验和信息解密，解密后的数据存入数据库。 根据thirdsession，从Redis中取出session_key 将用户信息进行解密，存入数据表 3.跳转至用户信息页面，检验登录态是否有效，获取全局用户信息填充至页面。 登录态有效 用户信息填充成功 现在，整个模块均开发测试完成。一个看似简单的模块换了另一种解决方法，这个过程我踩了许多坑，犯了许多低级的错误，因此决定写下这篇文章来总结一下自己的开发经验，让思路更清晰。若各位大神发现代码中有bug的话，可以关注我在后台留言告诉我哦。最后，RNG牛逼！","link":"/2018/09/15/miniLogin/"},{"title":"【学习日记】微信小程序仿朋友圈发布商品信息及图片","text":"本文使用的技术栈：小程序开发、SpringBoot、MyBatis、Redis 今天要写一个商城项目中的发布商品模块，需求跟闲鱼这样的app基本一致，就是基本的上传表单数据和图片。图片模块我想采用类似朋友圈的方式来完成，符合大部分用户的操作逻辑。 现在朋友圈发图片已经可以拖拽改变图片顺序或删除图片了，但是用小程序实现拖拽功能太麻烦了。所以，我将换一种方式来实现图片删除和预览，最后，再写两个后端接口，把商品信息和图片存入数据库。 这里前端用到了Vant Weapp的UI库 https://github.com/youzan/vant-weapp 先来看看前端页面的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;view class=\"page\"&gt; &lt;form bindsubmit='send'&gt; &lt;van-cell-group&gt; &lt;van-field required clearable left-icon=\"gift\" name=\"goodsName\" label=\"商品名称\" icon=\"question\" placeholder=\"请输入商品名\" bind:click-icon=\"onClickIcon\" /&gt; &lt;van-field type=\"textarea\" label=\"描述\" left-icon=\"records\" name=\"goodsDesc\" placeholder=\"请输入5-50个字\" autosize required border=\"{{ false }}\" /&gt; &lt;/van-cell-group&gt; &lt;view class=\"image_content\"&gt; &lt;view class='image' wx:for=\"{{img_url}}\"&gt; &lt;image class=\"deleteImg\" mode=\"aspectFill\" data-index='{{index}}' src=\"/img/deleteImg.png\" bindtap=\"deleteImg\"&gt;&lt;/image&gt; &lt;image class=\"moment_img\" mode=\"aspectFill\" data-index='{{index}}' src=\"{{item}}\" bindtap=\"previewImg\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class='image' style='display:{{hideAdd?\"none\":\"block\"}}'&gt; &lt;image bindtap=\"chooseimage\" class=\"moment_img\" src='/img/addImg.png'&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;van-cell-group&gt; &lt;van-field required clearable left-icon=\"gold-coin\" name=\"goodsPrice\" label=\"单价\" icon=\"question\" placeholder=\"请输入数字\" bind:click-icon=\"onClickIcon\" /&gt; &lt;van-field value=\"1\" label=\"数量\" left-icon=\"exchange\" name=\"goodsNum\" placeholder=\"\" required /&gt; &lt;van-field left-icon=\"chat\" name=\"goodsPhone\" label=\"联系方式\" required /&gt; &lt;van-field left-icon=\"location\" value=\"\" name=\"goodsAddress\" label=\"交易地点\" placeholder=\"例：学瀚楼下\" required /&gt; &lt;/van-cell-group&gt; &lt;button class=\"publishBtn\" type=\"primary\" form-type='submit'&gt;发布&lt;/button&gt; &lt;/form&gt;&lt;/view&gt; 效果如下图： 表单部分代码很简单，所以这里主要分析添加图片的代码逻辑。第一步，找一张添加照片的图标绑定一个wx.chooseImage事件，定义一个全局变量count作为当前选择的图片数量，使用户选择的图片在9张以内；定义一个数组，用于存放当前图片的url，在用户选择完照片后，该数组会更新，并用wx:for渲染至前端页面。123456789101112131415161718192021222324252627282930313233chooseimage: function () { var me = this; //动态更新当前用户可以上传的图片数 var count = 9 - that.data.img_url.length; wx.chooseImage({ count: count, // 默认9 sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有 sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有 success: function (res) { if (res.tempFilePaths.length &gt; 0) { //把每次选择的图push进数组 let img_url = that.data.img_url; for (let i = 0; i &lt; res.tempFilePaths.length; i++) { img_url.push(res.tempFilePaths[i]) } me.setData({ img_url: img_url }) //图如果满了9张，不显示添加图片图标 if (that.data.img_url.length &gt;= 8) { me.setData({ hideAdd: 1 }) } else { me.setData({ hideAdd: 0 }) } } } }) } 当图片数量达到9张，隐藏添加图片图标 第二步，给图片加上预览和删除功能，预览功能使用wx.previewImage绑定图片的索引值即可；删除功能则是在图片右上角加上一个删除图标来绑定删除事件，删除后实时更新图片列表。 1234567891011121314151617181920212223242526//预览图片previewImg:function(e){ var me = this; var img_url = me.data.img_url; var index = e.target.dataset.index; wx.previewImage({ urls: img_url, current : img_url[index], success:function(res){ console.log(res); } })},//删除图片deleteImg: function (e){ var me = this; var img_url = me.data.img_url; var index = e.target.dataset.index; img_url.splice(index, 1); me.setData({ img_url: img_url, //若当前图片超过9张，则隐藏添加图标；少于9张则显示添加图标。 hideAdd: me.data.img_url.length &lt;9 ? false : true })}, 第三步，上传商品信息和图片，我将这个功能分为两部分完成，首先将表单数据先上传，再将图片上传。这里假设用户已经成功使用微信登录小程序，且登录态保存已保存在本地缓存。在表单数据上传成功后，会返回一个商品ID到前端，再调用上传图片方法，将商品ID和每张图片的相对路径保存至数据库。实现代码如下。1234567891011121314151617181920212223242526272829303132333435//上传商品信息send:function(e){ var me = this; console.log(e); var goodsName = e.detail.value.goodsName; var goodsDesc = e.detail.value.goodsDesc; var goodsPrice = e.detail.value.goodsPrice; var goodsNum = e.detail.value.goodsNum; var goodsAddress = e.detail.value.goodsAddress; var goodsPhone = e.detail.value.goodsPhone; var thirdSession = wx.getStorageSync(\"thirdsession\") wx.showLoading({ title: '发布中--', }) var serverUrl = app.serverUrl; wx.request({ url: serverUrl + '/goods/uploadGoods', data: { thirdSession: thirdSession, goodsName: goodsName, goodsDesc: goodsDesc, goodsPrice: goodsPrice, goodsNum: goodsNum, goodsAddress: goodsAddress, goodsPhone: goodsPhone, }, method: \"GET\", success: function (res) { wx.hideLoading(); console.log(res.data.data); //商品信息上传成功后，上传商品图片 me.uploadGoodsImg(res.data.data); } }) } 需要注意的是，小程序的wx.uploadFile接口的资源路径是String类的。所以多图上传时，我会递归调用这个接口来完成。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//上传图片uploadGoodsImg: function (goodsId){ var me = this; var imgFilePaths = me.data.img_url; var count = me.data.count; var serverUrl = app.serverUrl; wx.showLoading({ title: '上传图片中--', }) wx.uploadFile({ url: serverUrl + '/goods/uploadGoodsImg', filePath: imgFilePaths[count], name: 'file', formData: { goodsId: goodsId }, success: function (res) { //可统计成功上传图片数 }, fail: function (res) { //可统计上传失败图片数 }, complete: function (res) { count++; me.setData({ count: count }) if (count &gt;= imgFilePaths.length) { var data = JSON.parse(res.data); console.log(data); wx.hideLoading(); if (data.status == 200) { wx.hideLoading(); wx.showToast({ title: '上传成功!~~', icon: 'success' }); me.setData({ count: 0 }) } else if (data.status == 500) { wx.showToast({ title: data.msg, }); } } else { //图片未上传完，递归调用本方法。 me.uploadGoodsImg(goodsId); } } }) } 第四步，后端接口使用IO流工具IOUtils将图片写入到指定的路径下，并将相对路径保存至数据库。这里存放图片路径采用了一个单独的表。具体代码如下：12345678910111213141516171819202122232425262728293031323334353637 //保存商品信息@GetMapping(\"/uploadGoods\")public IMoocJSONResult uploadFace(String thirdSession,String goodsName, String goodsDesc,double goodsPrice,String goodsPhone, int goodsNum,String goodsAddress) throws Exception { if (StringUtils.isBlank(thirdSession)) { return IMoocJSONResult.errorMsg(\"thirdSession is none\"); } String value = (String) redis.get(\"Wxuser-redis-session:\"+thirdSession); System.out.println(value); if (StringUtils.isBlank(value)) { return IMoocJSONResult.errorMsg(\"session timeout\"); } //解析json格式的str JSONObject json = JSONObject.parseObject(value); String openId = json.getString(\"openid\"); String goodsId = sid.nextShort(); Goods goods = new Goods(); goods.setId(goodsId); goods.setSellerId(openId); goods.setSellerPhone(goodsPhone); goods.setAddress(goodsAddress); goods.setGoodsDesc(goodsDesc); goods.setLikeCounts(0); goods.setGoodsName(goodsName); goods.setPrice(goodsPrice); goods.setGoodsNum(goodsNum); goodsService.saveGoods(goods); return IMoocJSONResult.ok(goodsId);} 上传图片接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@PostMapping(value=\"/uploadGoodsImg\" ,headers=\"content-type=multipart/form-data\")public IMoocJSONResult uploadGoodsImg(String goodsId,@RequestParam(\"file\") MultipartFile[] files) throws Exception { //文件保存的命名空间 String fileSpace=\"D:/cunjin-xianyu-test\"; //保存到数据库的相对路径 String uploadPathDB=\"/\"+goodsId+\"/img\"; FileOutputStream fileOutputStream=null; InputStream inputStream= null; try { if(files != null &amp;&amp; files.length&gt;0) { String fileName= files[0].getOriginalFilename(); if (StringUtils.isNotBlank(fileName)) { //文件保存的最终路径 String finalPath = fileSpace + uploadPathDB + \"/\" + fileName; //设置数据库保存的路径 uploadPathDB+=(\"/\"+fileName); File outFile=new File(finalPath); if (outFile.getParentFile()!=null || !outFile.getParentFile().isDirectory()) { //创建父文件夹 outFile.getParentFile().mkdirs(); } fileOutputStream = new FileOutputStream(outFile); inputStream = files[0].getInputStream(); IOUtils.copy(inputStream, fileOutputStream); }else { return IMoocJSONResult.errorMsg(\"上传出错\"); } } } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); return IMoocJSONResult.errorMsg(\"上传出错\"); }finally { if(fileOutputStream!=null) { fileOutputStream.flush(); fileOutputStream.close(); } } GoodsImg goodsImg = new GoodsImg(); goodsImg.setGoodsId(goodsId); goodsImg.setImg(uploadPathDB); goodsService.saveGoodsImg(goodsImg); return IMoocJSONResult.ok(\"上传成功\");} 好了，代码写完了，现在来进行前后端联调，测试一下。我们先选几张图，输一些数据 在本地新建一个文件夹，用于存放图片，路径与代码的命名空间一致。 好了，现在我们点击发布，观察数据库和本地文件。 可以看到，我们发布的商品信息和图片相对路径都已经存入数据库了，同时，本地也已经保存了这两张图片。测试成功！总结 数据库存放多张图片路径，除了用本文的方法，还可以使用一些特定符号将路径分隔开，存入商品信息表中，这样，即使上传多张图片也只会存入一行数据，不过这种方法也是在网上看过，自己还未实践过。 在使用wx.uploadFile接口时，要记得将content-type改为multipart/form-data。 使用IOUtils写文件的拷贝非常方便，无需各种输入流，然后读取line，输出到输出流。","link":"/2018/09/29/miniPublishImg/"}],"tags":[],"categories":[]}